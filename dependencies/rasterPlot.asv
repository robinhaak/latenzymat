function rasterPlot(spikeTimes, eventTimes, useMaxDur, trialType, plotColor, plotMaxSpikes, doSort)
% make a raster plot, syntax:
%   rasterPlot(spikeTimes, eventTimes, useMaxDur, trialType, color, plotMaxSpikes, doSort)
%   input:
%   - spikeTimes [S x 1]: spike times (s)
%   - eventTimes [T x 1]: event (start) times (s)
%   - useMaxDur: scalar or [pre post], time to include after/around event times (s)
%   - trialType: label for trialtype (e.g., orientation), same size as eventTimes
%   - plotColor: colors for plotting [3 x N], where N is unique trialtypes
%   - plotMaxSpikes: max number of spikes to plot (default: inf)
%   - doSort: boolean, sort spikes by trialType
% history:
% 6 August 2024
%   - created by Robin Haak
% 19 September 2024
%   - code clean-up to make it more user friendly
%   - added new default colormap
%   - include subfunctions for sharing

%% Prep
% Ensure correct orientation
spikeTimes = spikeTimes(:);
eventTimes = eventTimes(:);

% Default duration settings
if ~exist('useMaxDur', 'var') || isempty(useMaxDur)
    eventTimes = sort(eventTimes);
    useMaxDur = [0 min(diff(eventTimes))];
elseif isscalar(useMaxDur)
    useMaxDur = [0 useMaxDur];
end
assert(useMaxDur(1) <= 0, 'useMaxDur(1) must be a negative scalar.');
assert(useMaxDur(2) > 0, 'useMaxDur(2) must be a positive scalar.');

if ~exist('trialType', 'var') || isempty(trialType)
    trialType = ones(size(eventTimes));
end
[trialType, uniqueType, ~, ~, ~] = val2idx(trialType);
numTrialType = numel(uniqueType);

% Ensure the first color is black
if ~exist('plotColor', 'var') || isempty(plotColor) || size(plotColor, 1) ~= numTrialType
    colorsOut = generateColorblindColors(numTrialType - 1);
    colorsOut = colorsOut(randperm(size(colorsOut, 1)), :);
    plotColor = [0 0 0; colorsOut];
end

if ~exist('plotMaxSpikes', 'var') || isempty(plotMaxSpikes)
    plotMaxSpikes = inf;
end

if ~exist('doSort', 'var') || isempty(doSort)
    doSort = true;
end

% Subselect
if numel(spikeTimes) > plotMaxSpikes
    spikeTimes = spikeTimes(sort(randperm(numel(spikeTimes), plotMaxSpikes)));
end

%% Make raster plot
fifigure;
hold on;
offset = 0;

if doSort
    for thisTrialType = 1:numel(uniqueType)
        % Get event times
        thisTrialStarts = eventTimes(trialType == thisTrialType);

        % Get spike times in subset of trials
        [~, spikesPerEvent] = getRelSpikeTimes(spikeTimes, thisTrialStarts, useMaxDur);

        % Plot spikes per trial
        for thisTrial = 1:numel(thisTrialStarts)
            vecTimes = spikesPerEvent{thisTrial};
            line([vecTimes(:)'; vecTimes(:)'], [(thisTrial + offset) * ones(1, numel(vecTimes)) - 0.5; (thisTrial + offset) * ones(1, numel(vecTimes)) + 0.5], ...
                'Color', plotColor(thisTrialType, :), 'LineWidth', 1.5);
        end
        
        % Add label for this trial type at half the number of trials
        numTrials = numel(thisTrialStarts);
        yLabelPos = offset + round(numTrials / 2);
        
        % Add label only if there are multiple trial types
        if numTrialType > 1
            text(max(xlim) + 0.05, yLabelPos, sprintf('%d', uniqueType(thisTrialType)), ...
                'Color', plotColor(thisTrialType, :), 'FontSize', 10, 'FontWeight', 'bold', ...
                'HorizontalAlignment', 'left', 'VerticalAlignment', 'middle');
        end
        
        offset = offset + numTrials;
    end
else
    [~, spikesPerEvent] = getRelSpikeTimes(spikeTimes, eventTimes, useMaxDur);

    % Plot spikes per trial
    for thisTrial = 1:numel(eventTimes)
        vecTimes = spikesPerEvent{thisTrial};
        line([vecTimes(:)'; vecTimes(:)'], [thisTrial * ones(1, numel(vecTimes)) - 0.5; thisTrial * ones(1, numel(vecTimes)) + 0.5], ...
            'Color', plotColor(trialType(thisTrial), :), 'LineWidth', 1.5);
    end
end

hold off;

% Set figure properties
ylim([0.5 numel(eventTimes) + 0.5]);
xlim(useMaxDur);
xlabel('Time from event (s)');
ylabel('Trial');

% Add a secondary y-axis for labels
ax2 = axes('Position', [0.9 0.1 0.05 0.8], 'Color', 'none', 'YAxisLocation', 'right');
axis(ax2, 'off'); % Turn off the axis

% Add labels for each trialType on the right y-axis
if numTrialType > 1
    for thisTrialType = 1:numTrialType
        numTrials = numel(find(trialType == uniqueType(thisTrialType)));
        yLabelPos = offset + round(numTrials / 2) - numTrials; % Adjust to half
        text(ax2, 0, yLabelPos, sprintf('%d', uniqueType(thisTrialType)), ...
            'Color', plotColor(thisTrialType, :), 'FontSize', 10, 'FontWeight', 'bold', ...
            'HorizontalAlignment', 'right', 'VerticalAlignment', 'middle');
    end
end

end



%% helper functions
function [varDataOut,vecUnique,vecCounts,cellSelect,vecRepetition] = val2idx(varData)
%val2idx Transforms label-entries to consecutive integer-based data
%Syntax: [varDataOut,vecUnique,vecCounts,cellSelect,vecRepetition] = val2idx(varData)
%
%Used to be label2idx, but matlab now has a built-in with that name..

%try converting to vector
try
    varData2 = cell2vec(varData);
    if numel(varData2) == numel(varData)
        varData = varData2;
    end
catch
    %otherwise, don't do any transformations
end
varDataOut = nan(size(varData));
vecUnique = unique(varData);
vecCounts = zeros(size(vecUnique));
vecIdx = 1:length(vecUnique);
cellSelect = cell(1,length(vecUnique));
vecRepetition = zeros(1,length(vecUnique));
if iscell(vecUnique)
    %character array
    for intIdx=vecIdx
        indEntries = strcmp(varData,vecUnique{intIdx});
        cellSelect{intIdx} = indEntries;
        varDataOut(indEntries) = intIdx;
        vecCounts(intIdx) = sum(indEntries(:));
        vecRepetition(indEntries) = 1:sum(indEntries(:));
    end
else
    %numeric vector
    for intIdx=vecIdx
        indEntries = varData==vecUnique(intIdx);
        cellSelect{intIdx} = indEntries;
        varDataOut(indEntries) = intIdx;
        vecCounts(intIdx) = sum(indEntries(:));
        vecRepetition(indEntries) = 1:sum(indEntries(:));
    end
end
end

function colorCodes = generateColorblindColors(numColors)
% This function generates a list of RGB color codes with the specified
% number of colors using an extended custom palette. The function returns
% an [numColors x 3] matrix of RGB color codes.

%define an extended colorblind-friendly palette
cudPalette = [
    0.0, 0.6, 0.5; % Teal
    0.8, 0.6, 0.2; % Mustard
    0.9, 0.3, 0.4; % Coral
    0.5, 0.4, 0.8; % Purple
    0.7, 0.7, 0.7; % Light Gray
    0.3, 0.5, 0.8; % Blue
    0.8, 0.3, 0.5; % Pink
    0.4, 0.7, 0.3; % Green
    0.9, 0.7, 0.1; % Orange
    0.5, 0.5, 0.1; % Olive
    0.1, 0.5, 0.5; % Turquoise
    0.7, 0.4, 0.2; % Brown
    0.6, 0.2, 0.9; % Violet
    0.2, 0.6, 0.9; % Sky Blue
    0.9, 0.6, 0.4; % Peach
    0.4, 0.9, 0.6; % Mint
    0.8, 0.8, 0.4; % Light Yellow
    0.6, 0.4, 0.1; % Dark Brown
    0.3, 0.7, 0.7; % Sea Green
    0.9, 0.4, 0.7; % Salmon
    0.4, 0.4, 0.4; % Dark Gray
    0.6, 0.3, 0.5; % Plum
    0.2, 0.8, 0.4; % Lime
    0.5, 0.6, 0.7; % Slate Blue
    0.8, 0.5, 0.3; % Rust
    0.7, 0.2, 0.6; % Fuchsia
    0.2, 0.5, 0.8; % Ocean Blue
    0.9, 0.9, 0.6; % Light Olive
    0.3, 0.3, 0.9; % Periwinkle
    0.7, 0.6, 0.3; % Khaki
    0.6, 0.7, 0.6; % Sage
    0.9, 0.5, 0.3; % Apricot
    0.2, 0.8, 0.6; % Turquoise Green
    0.5, 0.7, 0.5; % Olive Green
    ];

%ensure numColors is at least as large as the number of colors in the palette
numPaletteColors = size(cudPalette, 1);
if numColors > numPaletteColors
    error('There are more conditions than colors, please define your own palette');
else
    colorCodes = cudPalette(1:numColors,:);
end
end

function [relSpikeTimes,spikesPerEvent] = getRelSpikeTimes(spikeTimes,eventTimes,useMaxDur,addArtifSpikes)
% create a vector of spike times relative to event times, syntax:
%   [relSpikeTimes,spikesPerEvent] = getRelSpikeTimes(spikeTimes,eventTimes,useMaxDur,addArtifSpks)
%   input:
%   - spikeTimes [S x 1]: spike times (s)
%   - eventTimes [T x 1]: event (start) times (s)
%   - useMaxDur: scalar or [pre post], time to include after/around event times (s)
%   - addArtifSpikes: boolean, add artificial spikes at beginning and end of epoch (default: true)
%
%   output:
%   - relSpikeTimes: spike times relative to events (s), sorted
%   - spikesPerEvent: relative spike times per event (s), sorted
%
% history:
% 1 Aug 2023
%   - created by Robin Haak
% 28 Aug 2023
%   - added spikesPerEvent as (optional) output
% 5 Feb 2024
%   - minor changes to code
% 9 April 2024
%   - added option to add two artificial spikes, at beginning and end
%   - useMaxDur instead of separate pre- and post-event time variables

%% prep
%ensure correct orientation
spikeTimes = spikeTimes(:);
eventTimes = eventTimes(:);

%check inputs
if ~exist('useMaxDur','var') || isempty(useMaxDur)
    eventTimes = sort(eventTimes);
    useMaxDur = min(diff(eventTimes));
end
if isscalar(useMaxDur), useMaxDur = [0 useMaxDur]; end
assert(useMaxDur(1)<=0,[mfilename ':WrongMaxDurInput'],...
    sprintf('UseMaxDur(1) must be a negative scalar, you requested %.2f',useMaxDur(1)));
assert(useMaxDur(2)>0,[mfilename ':WrongMaxDurInput'],...
    sprintf('UseMaxDur(2) must be a positive scalar, you requested %.2f',useMaxDur(2)));
if ~exist('addArtifSpikes','var') || isempty(addArtifSpikes)
    addArtifSpikes = false;
end

%% compute relative spike times
numEvents = length(eventTimes);
spikesPerEvent = cell(numEvents,1);
for event = 1:numEvents
    startTime = eventTimes(event);
    stopTime = startTime+useMaxDur(end);
    spikesPerEvent{event} = ...
        spikeTimes(spikeTimes>(startTime+useMaxDur(1)) & spikeTimes<stopTime)-startTime;
end

%sort ascending
spikesPerEvent = cellfun(@(x)sort(x),spikesPerEvent,'UniformOutput',false);
relSpikeTimes = vertcat(spikesPerEvent{:});
relSpikeTimes = sort(relSpikeTimes);

%% if requested, add artificial spikes to cover full epoch
if addArtifSpikes && ~isempty(relSpikeTimes)
    if relSpikeTimes(1) > useMaxDur(1)
        relSpikeTimes = [useMaxDur(1); relSpikeTimes];
    end
    if relSpikeTimes(end) < useMaxDur(end)
        relSpikeTimes = [relSpikeTimes; useMaxDur(2)];
    end
end
end

